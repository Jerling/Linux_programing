* Table of Contens  :TOC_2_gh:
- [[#简介和概述][简介和概述]]
  - [[#内核的任务][内核的任务]]
  - [[#实现策略][实现策略]]
  - [[#内核的组成部分][内核的组成部分]]

* 简介和概述
** 内核的任务
   内核是硬件与软件之间的中间层，作用是将应用程序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。
- 从应用程序角度看：内核是增强的计算机，将其抽象到一个高你层次上。
- 当若干程序在同五系统中并发运行时，可以将内核视为资源管理程序。内核负责将共享资源分配给系统进程, 同时保证系统完整性。
- 另一种视角是将内核视为库，提供一组面向系统的命令。比如：系统调用用于向计算机发送请求。借助于C标准库，系统调用对于应用程序就像是变通函数一样，调用方式和其他函数一样。
** 实现策略
   实现方面主要分两大范型：
- 微内核：最基本的功能直接由微内核实现。其他的功能委托给独立的进程，通过明确的通信接口与中心内核通信。如：文件系统、内存管理等。
  - 优点：系统各部分清楚划分，动态可扩展性好，运行时方便地切换重要组件。
  - 缺点：各组件间复杂通信需要额外的CPU时间，软面皮实用性方面进展甚微。
- 宏内核：是系统构建的传统方法。内核包括所有子系统：内存管理、文件系统、设备驱动程序等。
  - 优点：性能仍然强于微内核，Linux也是基于这种范型。
  - 缺点：内核中的每个函数都可以访问内核中的所有其他部分。编程不小心可能会导致源代码中出现复杂的嵌套。

    尽管目前Linux主要使用第二种范型，但其中已经引进了一个重要的革新：在系统运行中，模块可以插入到内核代码中，也可以移除，这使得可以向内核动态添加
功能，弥补了宏内核 的一些缺陷。模块特性依赖于内核与用户层之间设计精巧的通信方法，使得模块的热插拔和动态装载得以实现。
** 内核的组成部分
[[file:img/Snipaste_2018-12-26_14-00-32.png]]
*** 进程切换调试
- 内核借助于CPU的帮助，负责进程切换的技术细节。
- 内核还须确定如何在现存进程之间共享CPU时间。
*** UNIX进程
    两种创建新进程的机制：
    - fork 可以创建当前进程的一个副本，父进程和子进程只有PID(进程ID)不同。Linux使用写时复制(copy on write) 技术提高 fork 的操作
    效率。原理是将内存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进程和子进程可以共用一内存页。
    - exec 将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，将内容替换为新数据，然后开始执行新程序。
**** 线程
     一个进程可由多个线程组成，它们共享同样的数据和资源，但可能执行程序中不同的代码路径。

     Linux用clone方法创建线程，工作方式类似于 fork，但启用了精确的检查，以确认哪些资源与父进程共享、哪些资源为线程独立创建。
**** 命名空间
     在内核2.6的开发期间，对命名空间的支持被集成到了许多子系统中，让不同的进程可以看到不同的系统视图。

     好处：例如虚拟主机厂商不必为每个用户准备一台物理主机，而是通过称为容器的命名空间来建立系统的多个视图。从容器的内部来看这是
一个完整的Linux系统，而且与其他容器没有交互。
**** 地址空间与特权级别
     地址空间的最大长度与实际可用的物理内存数量无关，称为虚拟地址空间。从进程的角度看，地址空间只有一个进程，而无法感知其他进程的存在。

     系统中每个用户里程都有自身的虚拟地址范围，0-TASK_SIZE。而 TASK_SIZE-2^32 或 2^64 为内核空间，用户不能访问。TASK_SIZE 是一个特定于计算机
体系结构的常数，把地址空间按给定的比例分为两部分。
**** 特权级别
     Linux只使用两种不同的状态：内核态和用户态。关键差别在于对于高于 TASK_SIZE 的内存的访问。即：用户态进程不能访问可读取内核空间的数据，也无法执行内核空间的代码。

     内核态与用户态:
     - 系统调用：从用户态切换到内核态。
     - 中断: 与用户空间无关，无权访问用户空间。不能进入睡眠。
     - 内核线程：无权处理用户空间，可以进入睡眠，可以被高度器跟踪。用途：内存和块设备数据同步，帮助高度器在CPU上分配进程。
**** 虚拟和物理地址空间
     内核和CPU将物理内存映射到虚拟地址空间的方式：页表。物理内存页称为页帧，虚拟地址空间中称为页。
#+BEGIN_QUOTE
用户层总是指应用程序本身，而用户空间则不仅可以表示应用程序，还可以指代应用程序所运行的虚拟地址的一部分，与内核空间相对。
#+END_QUOTE
**** 页表
     将虚拟地址映射到物理地址的数据结构。

     Linu采用了四级页表，书中用三级页表阐述：

[[file:img/Snipaste_2018-12-26_15-39-06.png]]

- 优点：省内存，对虚拟地址空间中不需要的区域，不必创建中间目录或页表。
- 缺点：效率较低，每次访问必须逐级访问。
  - 内存管理单元(MMU)优化内存访问。
  - 频繁地址保存到转换后备缓冲器(TLB)的CPU高速缓存中。
***** 与CPU的交互
      内核与体系结构无关的部分总是假定使用四级页表。对于只支持二级或三级的CPU来说，内核中体系结构相关的代码必须通过空页表进行仿真。这部分的实现是与CPU无关的。
***** 内存映射
      一种抽象，将数据传输到进程的虚拟地址空间中。内核在实现设备驱动程序时直接使用了内存映射，对内存的读写会由系统重定向到设备。
**** 物理内存的分配
     内存分配和释放非常频繁，内核必须保证尽快完成。因此可以只分配完整的页帧，针内存划分为更小的的工作委托给用户空间的标准库。
***** 伙伴系统
      系统中的空闲内存块总是两两分组，每组中的两个内存块称为伙伴。它们的分配是独立的，但一旦它们都是空的，内核会将其合并为一个更大的内存块作为下一层某个内存块的伙伴。
***** slab 缓存
      将伙伴系统提供的页划分为更小的部分，为频繁使用的小对象实现了一个一般性的缓存。
      - 对频繁使用的对象，内核定义了只包含所需类型对象实例的缓存。
      - 小内存的分配，内核对不同大小的对象定义了一组slab缓存，可以像用户空间编程一样，用相同的函数访问这些缓存。不同的是这些函数加了前缀k，表明是与内核相关的：kmalloc和kfree。
[[file:img/Snipaste_2018-12-26_16-54-45.png]]
***** 交换和回收
      交换利用磁盘空间作为扩展内存，从而增大可用的内存。回收用于将内存映射被修改的内容与底层的块设备同步，也简称数据回写。
**** 计时
     内核必须测量时间以及不同时间点的时差，因此进程调试会用到。
**** 系统调用
系统调用分组：
- 进程管理：创建新进程、查询信息、调试
- 信号：发送信号、定时器以及相关处理机制
- 文件：创建、打开和关闭文件，读取和写入，查询信息和状态
- 目录和文件系统：创建、删除和重命名目录，查询信息，链接，变更目录
- 保护机制：读取和变更 UID/GID，命名空间的处理
- 定时器函数：定时器函数和统计信息
**** 驱动程序
     用于程序与系统连接的入输出通信。分类字符设备和块设备。
**** 网络
     Linux使用BSD的套接字抽象———应用程序、文件接口、内核的网络实现之间的代理。
**** 文件系统
     [[file:img/Snipaste_2018-12-27_09-32-37.png]]
**** 模块和热插拔
     模块用于在运行时动态地向内核添加或卸载功能，如设备驱动、文件系统、网络协议。本质是普通的程序。是支持热插拔必须的。
**** 缓存
     用于改进系统性能，以前有页缓存和块缓存，现在只有页缓存了。
**** 链表处理
     内核也需要处理链表。
**** 对象管理和引用计数
     内核需要跟踪记录C语言中结构的实例。此功能不仅可以避免代码复制，也可以为内核不同部分管理的对象提供了一致的视图。

一般性的内核对象机制：
- 引用计数
- 管理对象链表(集合)
- 集合加锁
- 将对象属性导出到用户空间(通过sysfs文件系统)
**** 数据类型
***** 类型的定义
      内核使用 =typedef= 定义各种数据类型。
***** 字节序
      大端和小端
***** per-cpu 变量
      通过 =DEFINE_PER_CP= 声明，为每个CPU创建变量的一个实例，可以通过 get_cpu获得。

好处：所需数据可能存在于处理器的缓存中，可以更快速地访问。可以绕过多处理系统中CPU同时访问变量引发的通信问题。
***** 访问用户空间
      源代码中的多处指针都标记为 =__user= , 对用户空间程序设计是未知的。内核用来指向用户地址空间中区域的指针，不能轻易访问这此区域。
