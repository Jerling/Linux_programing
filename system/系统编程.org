* Quick notes

** GCC
  [2018-11-04 日 09:58]
*** 1. gcc 工作流程

**** 1.1.1 预处理  -- E
- 宏替换
- 头文件展开
- 注释去掉
- xxx.c -> xxx.i(c文件)

**** 1.1.2 编译    -- S
- xxx.i -> xxx.s(汇编文件)

**** 1.1.3 汇编    -- c
- xxx.s -> xxx.o(二进制文件)

**** 1.1.4 链接
- xxx.o -> xxx(可执行文件)

*** 2. gcc 常用参数
- -v/--version 版本
- -I 编译的时候指定头文件的路径
- c 将汇编文件生成二进制文件，得到 .o 文件(还是源代码)
- o 指定生成的文件的名字
- g 需要gdb调试的时候
- D 在编译的时候指定一个宏（使用场景：测试程序）
- Wall 显示警告信息
- On 优化到代码， n 是优化级别： 1,2,3...

** 静态库和动态库
  [2018-11-04 日 10:14]
*** 1.库是什么
- 二进制文件
- 将源代码 —> 二进制格式的源代码
- 加密
*** 2.如何使用
- 头文件
- 制作出的库
*** 3.静态库的制作与使用
1. 命名规则
   - lib
   - xxx - 库的名字
   - .a
2. 制作步骤
   - 原材料：源代码（.c, .cpp, .cc)
   - 将.c文件生成.o
     - gcc a.c b.c -o -C
   - 将.o打包
     - ar rcs 静态库的名字 原材料
     - ar rcs libtest.a a.o b.o
     - 将.a 文件移动到 lib 文件夹
   - 库的使用：
     - 将 include 和 lib 文件夹给用户即可
     - gcc main.c -I ./include -L ./lib -l test - o appo
     - -L 指定库的路径 -l 指定库的名字取得lib和.a
3. 优缺点
   - 优点：
     - 静态库被打包到应用程序中加载速度快
     - 发布程序无需提供静态库，移植方便
   - 缺点：
     - 浪费系统资源，浪费内存
     - 更新、部署、发布麻烦

*** 4.动态库的制作与使用
- 命名规则
  - libxxx.so
- 制作步骤
  - 将源文件生成.o : gcc a.c b.c -C -fpic
  - 打包 ： gcc -shared *.o -o libxxx.so
- 库的使用
  - 头文件 a.h
  - 动态库 libxxx.so
  - 参考函数声明编程测试程序 main.c
    gcc main.c -I ./include -L ./lib -l xxx -o app
- 动态库无法加载
  - 使用 ldd app 查看那些动态库找不到
  - 使用环境变量
    - 临时设置：
      - 在终端： export LD_LIBRARY_PATH=./lib:$LD_LIBRARY
    - 永久设置：
      - 用户级别：～/.bashrc
      - 系统级别： /etc/profile
  - /etc/ld.so.cache 文件列表
    - 找到一个配置文件： /etc/ld.so.conf, 把 lib 的绝对路径添加到该文件
    - 执行一个命令： sudo ldconfig -v
- 知识点扩展：
  - dlopen, dlclose, dlsym
- 优缺点：
  - 优点
    - 动态库在内存你中只存在一份，避免了静态库的内存浪费，实现进程间资源共享
    - app 制作完后动态库没有加载到app中，升级简单
  - 缺点：
    - 加载速度比静态慢
    - 发布程序需要提供依赖的动态库

** Makefile 文件
  [2018-11-04 日 12:54]
*** 1. make
- gcc -- 编译器
- make -- linux自带的构建器
  - 构建的规则在 *makefile* 文件中
*** 2. makefile 的命名
- makefile
- Makefile
*** 3. makefile 的规则
- gcc a.c b.c c.c -o app
- 三部分：目标、依赖、命令
  - 目标：依赖
  - tab 缩进命令
  - makefile 中由一条或多条规则组成
*** 4. makefile的编写
- 第一个版本
  - app: a.c b.c c.c
        gcc a.c b.c c.c -o app
  - 缺点：效率低修改一个文件，所有的文件都会被全部重新编译
- 第二个版本
  - 工作原理
    - 检测依赖是否存在
    - 向下搜索下边的规则，如果有规则是用来生成查找的依赖的，执行规则中的命令
      - 依赖存在，判断是否需要更新
      - 原则：目标时间 > 依赖时间
  - 缺点：冗余
- 第三个版本
  - 自定义变量
    obj = a.o b.o c.o
    obj = 10
    变量的取值： aa=$(obj)
  - makefile自带的变量：大写
    - CPPFLAGS
    - CC
  - 自动变量
    - $@:规则中的目标
    - $<:规则中的第一个依赖
    - $^:规则中的多有依赖
    - 只能在规则命令中使用,不能在目标中使用
  - 可移植性差
- 第四个版本
  - makefile所有的函数都有返回值
  - 查找指定目录下指定类型的文件
    - src = $(wildcard ./*.c)
  - 匹配替换
    - obj = $(patsubst %.c, %.o, $(scr))
- 第五个版本
  - 编写一个清理项目的规则
    - clean:
      [-]rm *.o app or rm $(obj) $(target) [-f]
      如果在命令前面加 “-” 则执行失败继续执行，否则退出，在后面加 -f 跳过检查
  - 声明伪目标

** 阻塞与非阻塞
  [2018-11-04 日 16:06]

- 阻塞与非阻塞是文件的属性不是 read 函数的属性
- 普通文件：默认不阻塞
- 终端设备：默认阻塞
  - 管道
  - 套接字

** 进程相关概念

  [2018-11-04 日 19:16]

*** 1. 程序和进程
 - 程序：二进制文件，占用的磁盘空间
 - 进程：启动的程序
   - 所有的数据都在内存
   - 需要占用很多的系统资源（CPU, 物理内存）

*** 2. 并发和并行
 - 并发：是一个时间段的概念，是指同一时间段内交替处理多个进程，
 也就是说在某一时刻只执行一个进程，即宏观并行
 - 并行：是一个时间点的概念，是指在同一时间点处理多个进程

*** 3. PCB(进程控制块)(sched.h中定义的结构体)
1. 进程id
2. 进程的状态
3. 进程切换时需要保持和恢复的一些CPU寄存器
4. 描述虚拟地址空间的信息
5. 描述控制终端的信息
6. 当前的工作目录
7. umask 掩码
8. 文件描述符表
9. 和信号相关的信息
10. 用户id和组id
11. 会话和进程组
12. 进程可以使用资源上限

*** 4. 进程间的五种状态
1. 运行态：获得了CPU
2. 就绪态：有执行资格没有获取执行权（等待CPU）
3. 挂起态：没有执行资格，没有执行权
4. 初始态：资源准备好进入就绪态
5. 终止态：运行结束或者异常终止

** 进程控制

<2018-11-04 日>
*** 1. fork：pid_t fork(void);
[[file:images/深度截图_选择区域_20181104212536.png]]
- fork函数的返回值
  - >0:父进程的返回值
  - =0:子进程的返回值
- 子进程创建成功之后代码的执行位置
  - 父进程执行到哪儿就从哪儿开始
- 父子进程的执行顺序
  - 不一定，谁先抢到CPU，先执行
- 如何区分父子进程
  - 通过返回值
- getpid() 获取当前进程id
- getppid() 获取父进程id

*** 2. ps 和 kill
1. ps:不加参数只显示当前的shell 和 ps 本身的进程
   - a: 当前所有的用户
   - u: 用户的相关信息
   - x: 不依赖与终端的进程
   - j: 信息更全，如父进程id
2. kill：向指定进程发送信号

** exec 函数族

  [2018-11-04 日 21:32]

*** 1. exec函数族
- 让父子进程执行不相干的操作
- 能够替换进程地址空间中的源代码 .txt 段
- 当前程序中调用另外一个应用程序
  - 首先想到 exec 之前需要 fork
- 返回值
  - 如果函数执行成功不返回
  - 执行失败，打印错误信息，退出当前程序

*** 2. 执行指定目录下的程序
1. int execl(const char *path, const char *arg, ...);
  - path: 要执行的程序的绝对路径
  - 变参arg：要执行的程序需要的参数
  - 第一arg：占位（随便写点）
  - 后边的arg：命令的参数
  - 参数写完之后：NULL
  - 一般执行自己的写的程序

*** 3. 执行 PATH 环境变量能够搜到的程序
1. int execlp(const char *file, const char *arg, ...);
   - file: 执行程序名
   - arg：占位
   - 参数：arg 之后
   - NULL

** 进程回收

  [2018-11-04 日 23:41]

*** 1. 孤儿进程
- 父进程先于子进程退出，此时子进程叫孤儿进程
- 孤儿进程被 init 进程领养，init 进程成为孤儿进程的父进程
- 为了释放子进程占用的系统空间
  - 进程结束后，能够释放用户空间
  - 释放不了 PCB ， 必须由父进程释放

*** 2. 僵尸进程
- 子进程退出，父进程还存在，父进程不释放子进程的 PCB，
孩子就变成僵尸进程
- 是一个死掉的进程

*** 3. 进程回收
- wait - 阻塞函数
  - pid_t wait(int * status);
    - 函数作用：
      1. 阻塞并等待子进程退出
      2. 回收子进程残留资源
      3. 获取子进程结束状态（退出原因）
    - 返回值：-1: 回收失败，>0: 回收是子进程对应的 pid
    - 参数：status
      - 判断子进程是如何被退出的：正常退出、被某个信号杀死了
      - WIFEIXTED(status): 为非0, 则正常退出
        - WEXITSTATUS(status): 上述宏为真时，此宏获取退出状态(exit/return)的参数
      - WIFSIGNALED(status): 为非0，进程异常退出
        - WTERMSIG(status): 上述宏为真时，此宏取得使此进程退出的信号的编号
  - pid_t waitpid(pid_t pid, int status, int options);
    - 函数作用：同 wait
    - 参数：
      - pid：
        - pid == -1：等待任一子进程。与 wait 等效
        - pid > 0 : 等待其进程ID与pid相等的子进程
        - pid == 0: 等待其组ID相于调用进程的组ID的任一子进程
        - pid < -1: 等待其组ID等于pid的绝对值的任一子进程
      - status：子进程退出状态，同 wait
      - options: 设置为 WNOHANG, 函数非阻塞， 设置为 0, 函数阻塞
    - 返回值：
      - >0 : 返回清理掉的子进程ID
      - -1 : 无子进程
      - =0 : 参3，为WNOHANG, 且子进程正在运行

** 进程通信

  [2018-11-05 周一 09:23]

*** 1. IPC:进程间通信
- 4种方式
  1. *管道* -- 简单
  2. 信号 -- 系统开销小
  3. *共享内存* - 适用于所有进程之间
  4. 本地套接字 - 稳定

*** 2. 管道（匿名）

**** 2.1 管道的概念
- 本质：
  - 内核缓冲区
  - 伪文件 - 不占用磁盘空间
- 特点：
  - 两部分：
    - 读端，写端，对应两个文件描述符
    - 数据的写端流入，读端流出
  - 操作管道的进程被销毁后，管道自动释放
  - 管道默认是阻塞的，所以不能同时读写
    - 读写分离

**** 2.2 管道的原理
- 内部实现方式 : 队列
  - 环形队列
  - 特点：先进先出
- 缓冲区大小
  - 默认 4 K
  - 大小会根据实际情况 ~适当~ 调整

**** 2.3 管道的局限性
- 队列：
  - 数据只能读一次，不能重复读取
- 半双工：
  - 单工：数据单向传递
  - 半双工：数据可以双向传递，但同一时刻单向
  - 双工：数据同一时刻可双向传递
- 匿名管道：适用于所有进程（不限于父子或兄弟进程）

**** 2.4 创建匿名管道
- int pipe(int pipefd[2]);
  - fd - 传出参数
  - fd[0] 读端
  - fd[1] 写端

**** 2.5 父子进程适用管道通信
- 单个进程可以使用管道完成读写
- 父子进程是否需要 sleep 函数：根据读快写慢
  - 父进程读，关闭写端
  - 子进程写，关闭读端
[[file:images/深度截图_选择区域_20181105193112.png]]

- 兄弟进程通信
[[file:images/深度截图_选择区域_20181105194633.png]]

*** 3. 管道的读写行为
- 读操作
  - 有数据
    - read(fd) - 正常读，返回读出的字节数
  - 无数据
    - 写段全部关闭
      - read解除阻塞。返回0
      - 相当于读文件读到了尾部
    - 没有全部关闭
      - read阻塞
- 写操作
  - 读端全部关闭
    - 管道破裂，进程被终止
      - 内核给当前进程发信号 SIGPIPE
  - 读端没有全部关闭
    - 缓冲区写满了
      - write 阻塞
    - 缓冲区没有写满
      - write 继续写
- 如何设置非阻塞
  - 默认读写两端都阻塞
  - 设置读端为非阻塞pipe
    - fcntl -- 变参函数
      - 复制文件文件描述符
      - 修改文件属性 -- open 的时候对应 flag 属性
    - 设置方法：
      - 获取原来的 flags
      - int flags = fcntl(fd[0], F_GETFL); flags |= O_NONBLOCK;fcntl(fd[0], F_SETFL, flags);

*** 4. fifo

**** 4.1. 特点
- 有名管道
- 在磁盘上有一个文件
- 伪文件，在磁盘大小永远为0
- 在内核里有一个对应的缓冲区
- 半双工的通信方式

**** 4.2. 使用场景
没有血缘关系的进程间通信

**** 4.3. 创建方式
- 命令：mkfifo
- 函数：mkfifo

**** 4.4. fifo文件可以使用 IO 函数进行操作
- open/close
- read/write
- 不能进行 lseek

**** 4.5. 进程间通信
[[file:images/深度截图_选择区域_20181105204654.png]]
*** 5. 内存映射区

**** 5.1. mmap -- 创建内存映射区
- 作用: 将磁盘文件的数据映射到内存, 用户通过修改内存就能修改磁盘文件
- 函数原型：
[[file:images/深度截图_选择区域_20181105204236.png]]

- 返回值：
  - 映射区的首地址 -- 调用成功
  - 调用失败： MAP_FAILED

**** 5.2 munmap -- 释放内存映射区
- 函数原型: int munmap(void *addr, size_t length);
  - addr - -mmap的返回值,映射区的首地址
  - length -- mmap的第二个参数,映射区的长度

*** 6. 信号
- 产生
  1. 键盘：ctrl + c
  2. 命令：kill
  3. 系统函数：kill
  4. 软条件：定时器
  5. 硬件：段错误、除 0 错误
[[file:images/深度截图_选择区域_20181105233510.png]]

[[file:images/深度截图_选择区域_20181105234330.png]]

** 线程同步

  [2018-11-06 周二 16:32]

*** 哲学家进餐
[[file:images/Snipaste_2018-11-06_16-34-04.png]]
